fa√ßa com que voce possa escolher o nome logo ao iniciar o jogo, e ao clicar na op√ß√£o "2 jogadores" voce seja obrigado a escolher o segundo nome

import random
import pygame
import sys
from enum import Enum

pygame.init()

# === Configura√ß√µes iniciais ===
LARGURA_BASE, ALTURA_BASE = 400, 600
FPS = 60

# Cores
COR_BRANCO = (255, 255, 255)
COR_PRETO = (0, 0, 0)
COR_CINZA_ESCURO = (40, 40, 40)
COR_NOTURNO_FUNDO = (15, 15, 30)
COR_OURO = (255, 215, 0)
COR_PRATA = (192, 192, 192)

# Fontes
FONT_MENU = pygame.font.Font(None, 36)
FONT_PONTOS = pygame.font.Font(None, 28)
FONT_PLACAR = pygame.font.Font(None, 48)


# Enum para facilitar controles
class EstadoJogo(Enum):
    MENU_PRINCIPAL = 1
    MENU_DIFICULDADE = 2
    MENU_MODO = 3
    JOGANDO = 4
    SAIR = 5
    PLACAR = 6


class Dificuldade(Enum):
    FACIL = 1
    MEDIO = 2
    DIFICIL = 3
    IMPOSSIVEL = 4


class Tema(Enum):
    NORMAL = 1
    NOTURNO = 2


class Modificador(Enum):
    VELOCIDADE = 1
    INVULNERABILIDADE = 2
    ESCUDO = 3
    LENTIDAO = 4
    MAIS_PONTOS = 5


# Configura√ß√µes dos obst√°culos para cada dificuldade
CONFIG_DIFICULDADE = {
    Dificuldade.FACIL: {"freq_obstaculo": 40, "velocidade_base": 3},
    Dificuldade.MEDIO: {"freq_obstaculo": 30, "velocidade_base": 4},
    Dificuldade.DIFICIL: {"freq_obstaculo": 20, "velocidade_base": 5},
    Dificuldade.IMPOSSIVEL: {"freq_obstaculo": 10, "velocidade_base": 7},
}

# Lista de modificadores dispon√≠veis
LISTA_MODIFICADORES = [
    Modificador.VELOCIDADE,
    Modificador.INVULNERABILIDADE,
    Modificador.ESCUDO,
    Modificador.LENTIDAO,
    Modificador.MAIS_PONTOS,
]

# Carregamento das imagens dos carros
CARROS_IMGS = [
    pygame.transform.scale(pygame.image.load("jogador1.png"), (40, 40)),
    pygame.transform.scale(pygame.image.load("jogador2.png"), (40, 40)),
    pygame.transform.scale(pygame.image.load("jogador3.png"), (40, 40)),
]

# Carregamento das imagens dos obst√°culos (5 tipos)
OBSTACULOS_IMGS = [
    pygame.transform.scale(pygame.image.load(f"obstaculo{i}.png"), (40, 40)) for i in range(1, 6)
]

# Carregamento das imagens dos modificadores
MODIFICADORES_IMGS = {
    Modificador.VELOCIDADE: pygame.transform.scale(pygame.image.load("modificador1.png"), (40, 40)),
    Modificador.INVULNERABILIDADE: pygame.transform.scale(pygame.image.load("modificador2.png"), (40, 40)),
    Modificador.ESCUDO: pygame.transform.scale(pygame.image.load("modificador3.png"), (40, 40)),
    Modificador.LENTIDAO: pygame.transform.scale(pygame.image.load("modificador4.png"), (40, 40)),
    Modificador.MAIS_PONTOS: pygame.transform.scale(pygame.image.load("modificador5.png"), (40, 40)),
}


# Fun√ß√£o para desenhar texto centralizado
def desenhar_texto_centralizado(superficie, texto, fonte, cor, y):
    render = fonte.render(texto, True, cor)
    ret = render.get_rect(center=(superficie.get_width() // 2, y))
    superficie.blit(render, ret)


# Classe Jogador
class Jogador:
    def __init__(self, x, y, imagem, controles, numero_jogador):
        self.rect = pygame.Rect(x, y, 40, 40)
        self.imagem = imagem
        self.controles = controles  # dicion√°rio com teclas
        self.numero_jogador = numero_jogador
        self.velocidade_base = 5
        self.velocidade_atual = self.velocidade_base
        self.pontuacao = 0
        self.invulneravel_tempo = 0
        self.tem_escudo = False
        self.modificadores_ativos = []  # Lista para m√∫ltiplos modificadores
        self.vivo = True

    def atualizar(self, dt, largura, altura, keys):
        if not self.vivo:
            return

        # Calcula velocidade base com modificadores
        base_vel = self.velocidade_base

        # Aplica modificadores de velocidade (s√≥ o mais forte prevalece)
        if Modificador.VELOCIDADE in self.modificadores_ativos:
            base_vel = self.velocidade_base * 1.5
        elif Modificador.LENTIDAO in self.modificadores_ativos:
            base_vel = self.velocidade_base * 0.75

        self.velocidade_atual = base_vel

        # Movimenta√ß√£o
        if keys[self.controles['esquerda']] and self.rect.left > 0:
            self.rect.x -= self.velocidade_atual
        if keys[self.controles['direita']] and self.rect.right < largura:
            self.rect.x += self.velocidade_atual
        if keys[self.controles['cima']] and self.rect.top > 0:
            self.rect.y -= self.velocidade_atual
        if keys[self.controles['baixo']] and self.rect.bottom < altura:
            self.rect.y += self.velocidade_atual

        # Atualiza tempo de invulnerabilidade
        if self.invulneravel_tempo > 0:
            self.invulneravel_tempo -= dt
            if self.invulneravel_tempo <= 0:
                self.invulneravel_tempo = 0
                # Remove invulnerabilidade dos modificadores ativos
                if Modificador.INVULNERABILIDADE in self.modificadores_ativos:
                    self.modificadores_ativos.remove(Modificador.INVULNERABILIDADE)

    def ativar_modificador(self, modificador):
        # Adiciona √† lista de modificadores ativos
        if modificador not in self.modificadores_ativos:
            self.modificadores_ativos.append(modificador)

        if modificador == Modificador.INVULNERABILIDADE:
            self.invulneravel_tempo = 3500  # milissegundos
        elif modificador == Modificador.ESCUDO:
            self.tem_escudo = True
        elif modificador == Modificador.MAIS_PONTOS:
            # Pontua√ß√£o extra equivalente a 15 segundos de jogo (15 * 60 = 900 pontos)
            self.pontuacao += 900

    def desenhar(self, tela):
        if not self.vivo:
            return

        tela.blit(self.imagem, self.rect)
        # Se estiver invulner√°vel, piscar o jogador
        if self.invulneravel_tempo > 0:
            if (pygame.time.get_ticks() // 250) % 2 == 0:
                # Desenha um ret√¢ngulo branco piscando
                pygame.draw.rect(tela, (255, 255, 255), self.rect, 3)
        # Se tem escudo, desenha c√≠rculo azul em volta
        if self.tem_escudo:
            pygame.draw.circle(tela, (0, 150, 255), self.rect.center, 25, 3)


# Classe Obstaculo
class Obstaculo:
    def __init__(self, x, y, imagem, velocidade):
        self.rect = pygame.Rect(x, y, 40, 40)
        self.imagem = imagem
        self.velocidade = velocidade

    def atualizar(self):
        self.rect.y += self.velocidade

    def desenhar(self, tela):
        tela.blit(self.imagem, self.rect)


# Classe ModificadorObjeto (para modificadores que aparecem como obst√°culos)
class ModificadorObjeto:
    def __init__(self, x, y, modificador, velocidade):
        self.rect = pygame.Rect(x, y, 40, 40)
        self.modificador = modificador
        self.imagem = MODIFICADORES_IMGS[modificador]
        self.velocidade = velocidade  # Usa a mesma velocidade dos obst√°culos

    def atualizar(self):
        self.rect.y += self.velocidade

    def desenhar(self, tela):
        tela.blit(self.imagem, self.rect)


# Classe principal do jogo
class Jogo:
    def __init__(self):
        self.estado = EstadoJogo.MENU_PRINCIPAL
        self.dificuldade = Dificuldade.FACIL
        self.tema = Tema.NORMAL
        self.modificadores_selecionados = []
        self.num_jogadores = 1
        self.carro_selecionado_jogador1 = 0
        self.carro_selecionado_jogador2 = 1  # Carro diferente para o jogador 2
        self.tela = pygame.display.set_mode((LARGURA_BASE, ALTURA_BASE))
        pygame.display.set_caption("Jogo de Carros")
        self.clock = pygame.time.Clock()
        self.jogadores = []
        self.obstaculos = []
        self.modificadores_objetos = []  # Lista de modificadores que aparecem como obst√°culos
        self.tempo_inicio = 0
        self.tempo_jogo = 0
        self.tempo_ultimo_modificador = 0
        self.velocidade_terminal_tempo = 300000  # 5 minutos em milissegundos

        # Frequ√™ncia e velocidade base dos obst√°culos
        self.freq_obstaculo = CONFIG_DIFICULDADE[self.dificuldade]["freq_obstaculo"]
        self.velocidade_base_obstaculo = CONFIG_DIFICULDADE[self.dificuldade]["velocidade_base"]

        # Tema
        self.cor_fundo = COR_CINZA_ESCURO

        # Menu
        self.menu_opcoes = ["Jogar 1 Player", "Jogar 2 Players", "Dificuldade", "Modo", "Sair"]
        self.menu_selecionado = 0

        # Menu dificuldade
        self.menu_dificuldades = [d.name.capitalize() for d in Dificuldade]
        self.menu_dificuldade_selecionada = 0

        # Menu modo (carro, tema, modificadores)
        self.menu_modo_opcoes = ["Escolher Carro", "Tema", "Modificadores", "Voltar"]
        self.menu_modo_selecionado = 0
        self.carro_atual = 0
        self.tema_atual = 0
        self.modificadores_ativos = []  # Lista de modificadores selecionados (podem ser mais de um)
        self.modificadores_selecionados = []

    def resetar_jogo(self):
        # Cria jogadores e limpa obst√°culos
        self.obstaculos = []
        self.modificadores_objetos = []
        self.jogadores = []
        self.tempo_inicio = pygame.time.get_ticks()
        self.tempo_jogo = 0
        self.tempo_ultimo_modificador = 0

        # Frequ√™ncia e velocidade base dos obst√°culos conforme dificuldade
        config = CONFIG_DIFICULDADE[self.dificuldade]
        self.freq_obstaculo = config["freq_obstaculo"]
        self.velocidade_base_obstaculo = config["velocidade_base"]

        # Criar jogadores
        largura_tela = LARGURA_BASE
        if self.num_jogadores == 2:
            largura_tela = LARGURA_BASE * 2
            self.tela = pygame.display.set_mode((largura_tela, ALTURA_BASE))
        else:
            self.tela = pygame.display.set_mode((LARGURA_BASE, ALTURA_BASE))

        # Jogador 1 (direita)
        controles_jogador1 = {
            "cima": pygame.K_UP,
            "baixo": pygame.K_DOWN,
            "esquerda": pygame.K_LEFT,
            "direita": pygame.K_RIGHT,
        }
        jogador1 = Jogador(180 + (largura_tela - LARGURA_BASE), 500, CARROS_IMGS[self.carro_selecionado_jogador1],
                           controles_jogador1, 1)
        self.jogadores.append(jogador1)

        # Jogador 2 (esquerda), se houver
        if self.num_jogadores == 2:
            controles_jogador2 = {
                "cima": pygame.K_w,
                "baixo": pygame.K_s,
                "esquerda": pygame.K_a,
                "direita": pygame.K_d,
            }
            jogador2 = Jogador(180, 500, CARROS_IMGS[self.carro_selecionado_jogador2], controles_jogador2, 2)
            self.jogadores.insert(0, jogador2)  # fica na esquerda

        # Reset modificadores
        self.modificadores_ativos = []

    def criar_obstaculo(self):
        largura_tela = self.tela.get_width()
        x = random.randint(0, largura_tela - 40)

        # 10% de chance de ser um modificador (2% para cada um dos 5 tipos)
        if random.random() < 0.1 and self.modificadores_selecionados:
            modificador = random.choice(self.modificadores_selecionados)
            return ModificadorObjeto(x, -40, modificador, self.velocidade_base_obstaculo)
        else:
            img = random.choice(OBSTACULOS_IMGS)
            velocidade = self.velocidade_base_obstaculo
            return Obstaculo(x, -40, img, velocidade)

    def aplicar_modificador_aleatorio(self):
        if not self.modificadores_selecionados:
            return  # nenhum modificador selecionado

        # Aplica um modificador aleat√≥rio em um jogador aleat√≥rio
        modificador = random.choice(self.modificadores_selecionados)
        jogador = random.choice([j for j in self.jogadores if j.vivo])
        if jogador:
            jogador.ativar_modificador(modificador)

    def aumentar_velocidade_jogadores(self, tempo_jogo):
        # Aumenta velocidade gradualmente, at√© +100% em 5 minutos
        fator = min(tempo_jogo / self.velocidade_terminal_tempo, 1)
        for jogador in self.jogadores:
            if jogador.vivo:
                jogador.velocidade_base = 5 * (1 + fator)

        # Tamb√©m aumenta velocidade dos obst√°culos proporcionalmente
        self.velocidade_base_obstaculo = CONFIG_DIFICULDADE[self.dificuldade]["velocidade_base"] * (1 + fator)

    def mostrar_placar(self):
        # Ordena jogadores por pontua√ß√£o (do maior para o menor)
        jogadores_ordenados = sorted(self.jogadores, key=lambda j: j.pontuacao, reverse=True)

        self.estado = EstadoJogo.PLACAR
        esperando_input = True

        while esperando_input:
            self.tela.fill(COR_CINZA_ESCURO if self.tema == Tema.NORMAL else COR_NOTURNO_FUNDO)

            # T√≠tulo
            desenhar_texto_centralizado(self.tela, "PLACAR FINAL", FONT_PLACAR, COR_BRANCO, 80)

            # Primeiro lugar
            if len(jogadores_ordenados) > 0:
                desenhar_texto_centralizado(self.tela, "ü•á 1¬∫ LUGAR", FONT_MENU, COR_OURO, 160)
                desenhar_texto_centralizado(self.tela, f"Jogador {jogadores_ordenados[0].numero_jogador}", FONT_MENU, COR_BRANCO, 200)
                desenhar_texto_centralizado(self.tela, f"Pontua√ß√£o: {jogadores_ordenados[0].pontuacao}", FONT_MENU, COR_BRANCO, 240)

                # Desenha o carro do vencedor
                img_vencedor = pygame.transform.scale(jogadores_ordenados[0].imagem, (80, 80))
                rect_img = img_vencedor.get_rect(center=(self.tela.get_width() // 2, 300))
                self.tela.blit(img_vencedor, rect_img)

            # Segundo lugar (apenas se tiver 2 jogadores)
            if len(jogadores_ordenados) > 1:
                desenhar_texto_centralizado(self.tela, "ü•à 2¬∫ LUGAR", FONT_MENU, COR_PRATA, 400)
                desenhar_texto_centralizado(self.tela, f"Jogador {jogadores_ordenados[1].numero_jogador}", FONT_MENU, COR_BRANCO, 440)
                desenhar_texto_centralizado(self.tela, f"Pontua√ß√£o: {jogadores_ordenados[1].pontuacao}", FONT_MENU, COR_BRANCO, 480)

            # Instru√ß√£o para continuar
            desenhar_texto_centralizado(self.tela, "Pressione ESPA√áO para voltar ao menu", FONT_PONTOS, COR_BRANCO, 550)

            pygame.display.flip()

            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_SPACE or evento.key == pygame.K_RETURN or evento.key == pygame.K_ESCAPE:
                        esperando_input = False
                        self.estado = EstadoJogo.MENU_PRINCIPAL

            self.clock.tick(FPS)

    def atualizar(self, dt):
        keys = pygame.key.get_pressed()
        if self.estado == EstadoJogo.MENU_PRINCIPAL:
            self.atualizar_menu_principal(keys)
        elif self.estado == EstadoJogo.MENU_DIFICULDADE:
            self.atualizar_menu_dificuldade(keys)
        elif self.estado == EstadoJogo.MENU_MODO:
            self.atualizar_menu_modo(keys)
        elif self.estado == EstadoJogo.JOGANDO:
            self.atualizar_jogo(dt, keys)
        elif self.estado == EstadoJogo.PLACAR:
            # A tela de placar √© controlada pelo m√©todo mostrar_placar
            pass

    def atualizar_menu_principal(self, keys):
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_UP:
                    self.menu_selecionado = (self.menu_selecionado - 1) % len(self.menu_opcoes)
                elif evento.key == pygame.K_DOWN:
                    self.menu_selecionado = (self.menu_selecionado + 1) % len(self.menu_opcoes)
                elif evento.key == pygame.K_RETURN:
                    opcao = self.menu_opcoes[self.menu_selecionado]
                    if opcao == "Jogar 1 Player":
                        self.num_jogadores = 1
                        self.resetar_jogo()
                        self.estado = EstadoJogo.JOGANDO
                    elif opcao == "Jogar 2 Players":
                        self.num_jogadores = 2
                        self.resetar_jogo()
                        self.estado = EstadoJogo.JOGANDO
                    elif opcao == "Dificuldade":
                        self.estado = EstadoJogo.MENU_DIFICULDADE
                    elif opcao == "Modo":
                        self.estado = EstadoJogo.MENU_MODO
                    elif opcao == "Sair":
                        pygame.quit()
                        sys.exit()

    def atualizar_menu_dificuldade(self, keys):
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_UP:
                    self.menu_dificuldade_selecionada = (self.menu_dificuldade_selecionada - 1) % len(
                        self.menu_dificuldades)
                elif evento.key == pygame.K_DOWN:
                    self.menu_dificuldade_selecionada = (self.menu_dificuldade_selecionada + 1) % len(
                        self.menu_dificuldades)
                elif evento.key == pygame.K_RETURN:
                    self.dificuldade = list(Dificuldade)[self.menu_dificuldade_selecionada]
                    self.estado = EstadoJogo.MENU_PRINCIPAL
                elif evento.key == pygame.K_ESCAPE:
                    self.estado = EstadoJogo.MENU_PRINCIPAL

    def atualizar_menu_modo(self, keys):
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_UP:
                    self.menu_modo_selecionado = (self.menu_modo_selecionado - 1) % len(self.menu_modo_opcoes)
                elif evento.key == pygame.K_DOWN:
                    self.menu_modo_selecionado = (self.menu_modo_selecionado + 1) % len(self.menu_modo_opcoes)
                elif evento.key == pygame.K_RETURN:
                    opcao = self.menu_modo_opcoes[self.menu_modo_selecionado]
                    if opcao == "Escolher Carro":
                        if self.num_jogadores == 2:
                            self.menu_chooser_carro_2players()
                        else:
                            self.menu_chooser_carro(1)
                    elif opcao == "Tema":
                        self.menu_chooser_tema()
                    elif opcao == "Modificadores":
                        self.menu_chooser_modificadores()
                    elif opcao == "Voltar":
                        self.estado = EstadoJogo.MENU_PRINCIPAL
                elif evento.key == pygame.K_ESCAPE:
                    self.estado = EstadoJogo.MENU_PRINCIPAL

    def menu_chooser_carro(self, jogador_num):
        selecionado = self.carro_selecionado_jogador1 if jogador_num == 1 else self.carro_selecionado_jogador2
        rodando = True
        while rodando:
            self.tela.fill(COR_CINZA_ESCURO if self.tema == Tema.NORMAL else COR_NOTURNO_FUNDO)
            desenhar_texto_centralizado(self.tela, f"Escolha carro Jogador {jogador_num} (‚Üê ‚Üí para mudar, Enter para confirmar)",
                                        FONT_MENU, COR_BRANCO, 100)
            img = CARROS_IMGS[selecionado]
            rect_img = img.get_rect(center=(self.tela.get_width() // 2, self.tela.get_height() // 2))
            self.tela.blit(img, rect_img)
            pygame.display.flip()

            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_LEFT:
                        selecionado = (selecionado - 1) % len(CARROS_IMGS)
                    elif evento.key == pygame.K_RIGHT:
                        selecionado = (selecionado + 1) % len(CARROS_IMGS)
                    elif evento.key == pygame.K_RETURN:
                        if jogador_num == 1:
                            self.carro_selecionado_jogador1 = selecionado
                        else:
                            self.carro_selecionado_jogador2 = selecionado
                        rodando = False
                    elif evento.key == pygame.K_ESCAPE:
                        rodando = False
            self.clock.tick(FPS)

    def menu_chooser_carro_2players(self):
        # Primeiro jogador escolhe
        self.menu_chooser_carro(1)
        # Segundo jogador escolhe
        self.menu_chooser_carro(2)

    def menu_chooser_tema(self):
        selecionado = self.tema_atual
        rodando = True
        opcoes_tema = ["Normal", "Noturno"]

        while rodando:
            # Define a cor de fundo baseada no tema selecionado
            cor_fundo = COR_CINZA_ESCURO if selecionado == 0 else COR_NOTURNO_FUNDO
            self.tela.fill(cor_fundo)

            desenhar_texto_centralizado(self.tela, "Escolha o tema (‚Üê ‚Üí para mudar, Enter para confirmar)", FONT_MENU,
                                        COR_BRANCO, 100)
            desenhar_texto_centralizado(self.tela, opcoes_tema[selecionado], FONT_MENU, COR_BRANCO, 200)

            pygame.display.flip()

            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_LEFT:
                        selecionado = (selecionado - 1) % len(opcoes_tema)
                    elif evento.key == pygame.K_RIGHT:
                        selecionado = (selecionado + 1) % len(opcoes_tema)
                    elif evento.key == pygame.K_RETURN:
                        self.tema_atual = selecionado
                        self.tema = Tema.NORMAL if selecionado == 0 else Tema.NOTURNO
                        rodando = False
                    elif evento.key == pygame.K_ESCAPE:
                        rodando = False
            self.clock.tick(FPS)

    def menu_chooser_modificadores(self):
        selecionados = self.modificadores_selecionados.copy()
        rodando = True
        opcoes_modificadores = [m.name.capitalize() for m in LISTA_MODIFICADORES]
        selecionado = 0

        while rodando:
            self.tela.fill(COR_CINZA_ESCURO if self.tema == Tema.NORMAL else COR_NOTURNO_FUNDO)
            desenhar_texto_centralizado(self.tela,
                                        "Selecione modificadores (Espa√ßo para selecionar, Enter para confirmar)",
                                        FONT_MENU, COR_BRANCO, 50)
            desenhar_texto_centralizado(self.tela, "Setas para navegar, ESC para voltar", FONT_PONTOS, COR_BRANCO, 90)

            # Desenha caixa de texto para os modificadores selecionados
            pygame.draw.rect(self.tela, COR_PRETO, (50, 350, self.tela.get_width() - 100, 150))
            pygame.draw.rect(self.tela, COR_BRANCO, (50, 350, self.tela.get_width() - 100, 150), 2)

            texto_selecionados = "Modificadores selecionados: " + ", ".join([m.name.capitalize() for m in selecionados])
            if not selecionados:
                texto_selecionados = "Modificadores selecionados: Nenhum"

            # Quebra o texto em v√°rias linhas se necess√°rio
            linhas = []
            palavras = texto_selecionados.split()
            linha_atual = ""
            for palavra in palavras:
                test_linha = linha_atual + palavra + " "
                if FONT_PONTOS.size(test_linha)[0] < self.tela.get_width() - 120:
                    linha_atual = test_linha
                else:
                    linhas.append(linha_atual)
                    linha_atual = palavra + " "
            if linha_atual:
                linhas.append(linha_atual)

            for i, linha in enumerate(linhas):
                desenhar_texto_centralizado(self.tela, linha, FONT_PONTOS, COR_BRANCO, 370 + i * 25)

            for i, opcao in enumerate(opcoes_modificadores):
                cor = COR_BRANCO
                prefixo = "[X] " if LISTA_MODIFICADORES[i] in selecionados else "[ ] "
                if i == selecionado:
                    cor = (255, 255, 0)  # Amarelo para o selecionado

                desenhar_texto_centralizado(self.tela, prefixo + opcao, FONT_MENU, cor, 150 + i * 40)

            pygame.display.flip()

            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_UP:
                        selecionado = (selecionado - 1) % len(opcoes_modificadores)
                    elif evento.key == pygame.K_DOWN:
                        selecionado = (selecionado + 1) % len(opcoes_modificadores)
                    elif evento.key == pygame.K_SPACE:
                        modificador = LISTA_MODIFICADORES[selecionado]
                        if modificador in selecionados:
                            selecionados.remove(modificador)
                        else:
                            selecionados.append(modificador)
                    elif evento.key == pygame.K_RETURN:
                        self.modificadores_selecionados = selecionados
                        rodando = False
                    elif evento.key == pygame.K_ESCAPE:
                        rodando = False
            self.clock.tick(FPS)

    def atualizar_jogo(self, dt, keys):
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_ESCAPE:
                    self.estado = EstadoJogo.MENU_PRINCIPAL

        # Atualiza tempo de jogo
        tempo_atual = pygame.time.get_ticks()
        self.tempo_jogo = tempo_atual - self.tempo_inicio

        # Aumenta velocidade com o tempo
        self.aumentar_velocidade_jogadores(self.tempo_jogo)

        # Cria obst√°culos aleatoriamente
        if random.randint(1, self.freq_obstaculo) == 1:
            novo_objeto = self.criar_obstaculo()
            if isinstance(novo_objeto, Obstaculo):
                self.obstaculos.append(novo_objeto)
            else:
                self.modificadores_objetos.append(novo_objeto)

        # Aplica modificadores aleat√≥rios a cada 30 segundos
        if self.tempo_jogo - self.tempo_ultimo_modificador > 30000:  # 30 segundos
            self.aplicar_modificador_aleatorio()
            self.tempo_ultimo_modificador = self.tempo_jogo

        # Atualiza jogadores
        for jogador in self.jogadores:
            if jogador.vivo:
                jogador.atualizar(dt, self.tela.get_width(), self.tela.get_height(), keys)
                jogador.pontuacao += 1  # Pontua√ß√£o aumenta com o tempo

        # Atualiza obst√°culos
        for obstaculo in self.obstaculos[:]:
            obstaculo.atualizar()
            if obstaculo.rect.y > self.tela.get_height():
                self.obstaculos.remove(obstaculo)

        # Atualiza modificadores objetos
        for modificador_obj in self.modificadores_objetos[:]:
            modificador_obj.atualizar()
            if modificador_obj.rect.y > self.tela.get_height():
                self.modificadores_objetos.remove(modificador_obj)

        # Verifica colis√µes entre jogadores (apenas no modo 2 players)
        if self.num_jogadores == 2:
            jogador1, jogador2 = self.jogadores
            if jogador1.vivo and jogador2.vivo and jogador1.rect.colliderect(jogador2.rect):
                # Apenas jogadores sem invulnerabilidade morrem
                if Modificador.INVULNERABILIDADE not in jogador1.modificadores_ativos:
                    jogador1.vivo = False
                if Modificador.INVULNERABILIDADE not in jogador2.modificadores_ativos:
                    jogador2.vivo = False

        # Verifica colis√µes com obst√°culos
        for jogador in self.jogadores:
            if not jogador.vivo:
                continue

            # Jogador est√° protegido se tiver invulnerabilidade
            if Modificador.INVULNERABILIDADE in jogador.modificadores_ativos:
                continue

            for obstaculo in self.obstaculos[:]:
                if jogador.rect.colliderect(obstaculo.rect):
                    if jogador.tem_escudo:
                        jogador.tem_escudo = False
                        # Remove escudo dos modificadores ativos
                        if Modificador.ESCUDO in jogador.modificadores_ativos:
                            jogador.modificadores_ativos.remove(Modificador.ESCUDO)
                        self.obstaculos.remove(obstaculo)
                    else:
                        jogador.vivo = False
                        # Se for modo 2 players e ambos morreram, mostra placar
                        if self.num_jogadores == 2 and all(not j.vivo for j in self.jogadores):
                            self.mostrar_placar()
                            return
                        # Se for modo 1 player, volta ao menu
                        elif self.num_jogadores == 1:
                            self.estado = EstadoJogo.MENU_PRINCIPAL
                            return

        # Verifica colis√µes com modificadores
        for jogador in self.jogadores:
            if not jogador.vivo:
                continue

            for modificador_obj in self.modificadores_objetos[:]:
                if jogador.rect.colliderect(modificador_obj.rect):
                    jogador.ativar_modificador(modificador_obj.modificador)
                    self.modificadores_objetos.remove(modificador_obj)

    def desenhar(self):
        # Define a cor de fundo baseada no tema
        if self.tema == Tema.NORMAL:
            self.cor_fundo = COR_CIN